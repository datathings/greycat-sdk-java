@library("std", "6.1.82-dev");

// @library("algebra");
// @library("decisiontrees"); // Non-existent
// @library("network");
// @library("patterns");
// @library("sql"); // reference to sql_n non-existing class
// @library("useragent"); // Tricky useragent.useragent is tricky

use io;
use runtime;

fn minimal_fail() {
    var out = AbiWriter::new("fail.gcb");
    out.write("${"Hello world!"}");
    out.write("${"Hello world!"}");
    out.write(GeoBox::new(13_geo, 37_geo));
    out.write(GeoCircle::new(42_geo, 13.37));
    out.write(RuntimeInfo {
        version: "",
        arch: "",
        timezone: TimeZone::Europe_Luxembourg,
        license: License {
          start: 13_time,
          end: 37_time,
          max_workers: 12,
          max_memory: 42,
          max_store: 0,
        },
        io_threads: 13,
        bg_threads: 37,
        fg_threads: 12,
        mem_total: 42,
        mem_worker: 0,
        nb_ctx: 1,
      });
}

fn main() {
  var out = AbiWriter::new("out.gcb");
  write_std(out);
}

fn write_std(out: AbiWriter) {
  write_core(out);
  write_runtime(out);
}

fn write_core(out: AbiWriter) {
  out.write("${"Hello world"}");
  // out.write(GeoBox::new(13_geo, 37_geo)); // first byte: 13
  out.write(nodeList<int>::new());
  out.write(TimeZone::Europe_Luxembourg);
  out.write(node<float>::new(13.37));
  out.write(Error::new(""));
  out.write(ErrorCode::none);
  out.write(SamplingMode::adaptative);
  out.write(DurationUnit::days);
  out.write(TensorType::c128);
  out.write(Table<node>::new(0, false));
  out.write(42_geo);
  out.write(Tensor::new());
  // out.write(GeoCircle::new(42_geo, 13.37)); // first byte: 42
  out.write(Date::new(2012, 12, 12, 12, 12, 12, 12, TimeZone::Europe_Luxembourg));
  out.write(Map<geo, time>::new());
  out.write(duration::new(12, DurationUnit::microseconds));
  out.write(nodeTime<nodeGeo>::new());
  out.write(Array<nodeTime>::new(0));
  out.write(Tuple<Array, Map>::new(Array::new(0), Map::new()));
  out.write(nodeIndex<Tuple>::new());
  out.write(GeoPoly::new([13_geo, 37_geo, 13_geo]));
  out.write(12_time);
  out.write(DatePart::days);
  out.write(nodeGeo<DatePart>::new());
}

fn write_runtime(out: AbiWriter) {
  // Task: first byte: 0
  out.write(TaskStatus::cancelled);
  // out.write(Runtime {});
  out.write(RuntimeInfo {
      version: "",
      arch: "",
      timezone: TimeZone::Europe_Luxembourg,
      license: License {
        start: 13_time,
        end: 37_time,
        max_workers: 12,
        max_memory: 42,
        max_store: 0,
      },
      io_threads: 13,
      bg_threads: 37,
      fg_threads: 12,
      mem_total: 42,
      mem_worker: 0,
      nb_ctx: 1,
    });
  out.write(SecurityFields {});
  out.write(UserGroup {
      id: 42,
      name: "",
      activated: true,
    });
  out.write(OpenIDConnect {
      url: "",
      clientId: "",
    });
  out.write(UserRole {
      name: "",
      permissions: [],
    });
  out.write(PeriodicTask {
      name: "",
      user_id: 12,
      start: 13_time,
      every: duration::new(37, DurationUnit::microseconds),
    });
  out.write(User {
      id: 12,
      name: "",
      activated: false,
      external: true,
    });
  out.write(UserGroupPolicy {
      group_id: 12,
      type: UserGroupPolicyType::execute,
    });
  out.write(UserGroupPolicyType::read);
  out.write(License {
      start: 13_time,
      end: 37_time,
      max_workers: 12,
      max_memory: 42,
      max_store: 0,
    });
  out.write(StoreStat {
      capacity_bytes: 13,
      allocated_bytes: 37,
      allocated_ratio: 13.37,
      remained_bytes: 12,
      remained_ratio: 4.20,
      used_bytes: 42,
      used_ratio: 0.1,
      available_bytes: 0,
      available_ratio: 0.2,
    });
  out.write(System {});
  out.write(SecurityPolicy {
      entities: [],
      credentials: Map<String, UserCredential>::new(),
      roles: Map<String, UserRole>::new(),
    });
}
